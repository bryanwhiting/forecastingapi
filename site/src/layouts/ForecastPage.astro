---
import MainLayout from './MainLayout.astro';
import Navbar from '../components/Navbar.astro';

const { data } = Astro.props;
const history = data.history ?? [];
const forecast = data.forecast ?? [];
const backtest = data.backtest ?? [];

const runTitle = data?.meta?.slug || data.request?.run_name_root || (data.request?.series_names || []).join(', ') || 'series';

const seriesIds = [...new Set([
  ...history.map((r) => r.unique_id),
  ...forecast.map((r) => r.unique_id),
])];

const parseDs = (v) => {
  const s = String(v ?? '');
  const normalized = s.includes('T') ? s : s.replace(' ', 'T');
  const d = new Date(normalized);
  return Number.isNaN(d.getTime()) ? null : d;
};

const svgChartForSeries = (seriesId, valuesType = 'forecast') => {
  const hRows = history.filter((r) => r.unique_id === seriesId).map((r) => ({ ...r, iso: parseDs(r.ds)?.toISOString() })).filter((r) => r.iso);
  const fRows = forecast.filter((r) => r.unique_id === seriesId).map((r) => ({ ...r, iso: parseDs(r.ds)?.toISOString() })).filter((r) => r.iso);
  const labels = [...new Set([...hRows.map((r) => r.iso), ...fRows.map((r) => r.iso)])].sort();

  const actualValues = labels.map((l) => {
    const row = hRows.find((r) => r.iso === l);
    return row ? Number(row.y) : null;
  });

  const modelNames = [...new Set(fRows.map((r) => r.model))];
  const modelSeries = modelNames.map((model) => ({
    model,
    values: labels.map((l) => {
      const row = fRows.find((r) => r.iso === l && r.model === model);
      return row ? Number(row.yhat) : null;
    }),
  }));

  const allY = [
    ...actualValues.filter((v) => Number.isFinite(v)),
    ...modelSeries.flatMap((s) => s.values.filter((v) => Number.isFinite(v))),
  ];
  const yMin = allY.length ? Math.min(...allY) : 0;
  const yMax = allY.length ? Math.max(...allY) : 1;

  const W = 920;
  const H = valuesType === 'backtest' ? 240 : 320;
  const PAD = { t: 18, r: 18, b: 40, l: 44 };
  const innerW = W - PAD.l - PAD.r;
  const innerH = H - PAD.t - PAD.b;

  const xFor = (i) => PAD.l + (labels.length <= 1 ? 0 : (i / (labels.length - 1)) * innerW);
  const yFor = (v) => {
    if (!Number.isFinite(v)) return null;
    const range = yMax - yMin || 1;
    return PAD.t + (1 - (v - yMin) / range) * innerH;
  };

  const toPath = (arr) => {
    let d = '';
    arr.forEach((v, i) => {
      const y = yFor(v);
      if (y === null) return;
      const x = xFor(i);
      d += d ? ` L ${x} ${y}` : `M ${x} ${y}`;
    });
    return d;
  };

  const actualPath = toPath(actualValues);
  const colors = ['#ef4444', '#22c55e', '#a855f7', '#f97316', '#14b8a6'];

  return { W, H, PAD, innerW, innerH, labels, actualValues, actualPath, modelSeries, colors, xFor, yFor, yMin, yMax };
};


const buildSmapeSpark = (rows) => {
  const W = 920, H = 200, PAD = { t: 16, r: 16, b: 32, l: 38 };
  const vals = rows.map((r) => Number(r.smape || 0));
  const min = vals.length ? Math.min(...vals) : 0;
  const max = vals.length ? Math.max(...vals) : 1;
  const range = max - min || 1;
  const x = (i) => PAD.l + (rows.length <= 1 ? 0 : (i / (rows.length - 1)) * (W - PAD.l - PAD.r));
  const y = (v) => PAD.t + (1 - ((v - min) / range)) * (H - PAD.t - PAD.b);
  let path = '';
  rows.forEach((r, i) => {
    const xv = x(i), yv = y(Number(r.smape || 0));
    path += path ? ` L ${xv} ${yv}` : `M ${xv} ${yv}`;
  });
  const points = rows.map((r, i) => ({ x: x(i), y: y(Number(r.smape || 0)) }));
  return { W, H, PAD, path, points };
};

const backtestBySeries = seriesIds.map((sid) => {
  const rows = backtest.filter((r) => r.unique_id === sid);
  const byModel = [...new Set(rows.map((r) => r.model))].map((m) => ({
    model: m,
    rows: rows.filter((r) => r.model === m).sort((a, b) => Number(a.window) - Number(b.window)),
  }));
  return { sid, rows, byModel };
});
---
<MainLayout title={`Forecast ${runTitle}`}>
  <Navbar />
  <h1 class="text-2xl font-bold mt-4">Forecast: {runTitle}</h1>
  <p class="text-slate-400 mt-1">Backend: {data.backend} · Granularity: {data.request.granularity} · Horizon: {data.request.horizon}</p>
  {data?.meta?.github?.run_url && <p class="text-sm mt-1"><a href={data.meta.github.run_url} target="_blank" rel="noreferrer" class="text-sky-300">GitHub action run ↗</a></p>}

  <section class="mt-4 space-y-4">
    {seriesIds.map((sid) => {
      const chart = svgChartForSeries(sid);
      const back = backtestBySeries.find((x) => x.sid === sid);
      return (
        <article class="rounded-xl border border-slate-700 bg-slate-900/70 p-4">
          <h2 class="font-semibold mb-2">Series: {sid}</h2>

          <h3 class="text-sm text-slate-300 mb-2">Main forecast</h3>
          <div class="overflow-x-auto">
            <svg viewBox={`0 0 ${chart.W} ${chart.H}`} class="min-w-[760px] w-full rounded bg-slate-950">
              <rect x={chart.PAD.l} y={chart.PAD.t} width={chart.innerW} height={chart.innerH} fill="none" stroke="#1e293b" />
              {Array.from({ length: 5 }).map((_, i) => {
                const y = chart.PAD.t + (i / 4) * chart.innerH;
                const val = (chart.yMax - ((i / 4) * (chart.yMax - chart.yMin))).toFixed(1);
                return (
                  <g>
                    <line x1={chart.PAD.l} y1={y} x2={chart.W - chart.PAD.r} y2={y} stroke="#0f172a" />
                    <text x="6" y={y + 4} font-size="11" fill="#94a3b8">{val}</text>
                  </g>
                );
              })}

              {chart.actualPath && <path d={chart.actualPath} fill="none" stroke="#38bdf8" stroke-width="2" />}
              {chart.actualValues.map((v, i) => {
                const y = chart.yFor(v);
                if (y === null) return null;
                return <circle cx={chart.xFor(i)} cy={y} r="2.8" fill="#38bdf8" />;
              })}

              {chart.modelSeries.map((s, idx) => {
                const d = (() => {
                  let p = '';
                  s.values.forEach((v, i) => {
                    const y = chart.yFor(v);
                    if (y === null) return;
                    const x = chart.xFor(i);
                    p += p ? ` L ${x} ${y}` : `M ${x} ${y}`;
                  });
                  return p;
                })();

                return (
                  <>
                    {d && <path d={d} fill="none" stroke={chart.colors[idx % chart.colors.length]} stroke-width="2" stroke-dasharray="6 4" />}
                    {s.values.map((v, i) => {
                      const y = chart.yFor(v);
                      if (y === null) return null;
                      return <circle cx={chart.xFor(i)} cy={y} r="2.5" fill={chart.colors[idx % chart.colors.length]} />;
                    })}
                  </>
                );
              })}
            </svg>
          </div>

          <div class="mt-2 flex flex-wrap gap-3 text-xs text-slate-300">
            <span class="inline-flex items-center gap-1"><span class="inline-block w-4 h-[2px] bg-sky-400"></span>Actual</span>
            {chart.modelSeries.map((s, idx) => (
              <span class="inline-flex items-center gap-1"><span class="inline-block w-4 h-[2px]" style={`background:${chart.colors[idx % chart.colors.length]}`}></span>Forecast ({s.model})</span>
            ))}
          </div>

          <details class="mt-4 rounded-lg border border-slate-700 bg-slate-950/40 p-3">
            <summary class="cursor-pointer font-semibold text-sm">Backfill testing + accuracies</summary>
            {back && back.rows.length > 0 ? (
              <div class="mt-3 space-y-3">
                {back.byModel.map((m, mi) => {
                  const spark = buildSmapeSpark(m.rows);
                  const color = ['#ef4444','#22c55e','#a855f7','#f97316'][mi%4];
                  return (
                    <div class="rounded border border-slate-700 p-2">
                      <div class="text-xs text-slate-300 mb-1">{m.model} SMAPE by backtest window</div>
                      <div class="overflow-x-auto">
                        <svg viewBox={`0 0 ${spark.W} ${spark.H}`} class="min-w-[680px] w-full rounded bg-slate-950">
                          <rect x={spark.PAD.l} y={spark.PAD.t} width={spark.W-spark.PAD.l-spark.PAD.r} height={spark.H-spark.PAD.t-spark.PAD.b} fill="none" stroke="#1e293b" />
                          <path d={spark.path} fill="none" stroke={color} stroke-width="2" />
                          {spark.points.map((pt) => <circle cx={pt.x} cy={pt.y} r="3" fill={color} />)}
                        </svg>
                      </div>
                    </div>
                  );
                })}

                <div class="overflow-x-auto">
                  <table class="min-w-[760px] text-sm w-full">
                    <thead><tr class="text-slate-300"><th class="p-2 text-left">Window</th><th class="p-2 text-left">Model</th><th class="p-2 text-left">SMAPE</th><th class="p-2 text-left">Holdout</th></tr></thead>
                    <tbody>
                      {back.rows.sort((a,b)=>Number(a.window)-Number(b.window)).map((row) => (
                        <tr><td class="p-2">{row.window}</td><td class="p-2">{row.model}</td><td class="p-2">{row.smape}</td><td class="p-2">{String(row.holdout_start)} → {String(row.holdout_end)}</td></tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            ) : (
              <p class="mt-2 text-sm text-slate-400">No backtest rows for this series yet (need more history or windows).</p>
            )}
          </details>
        </article>
      );
    })}
  </section>

  <details class="mt-4 rounded-xl border border-slate-700 bg-slate-900/70 p-4">
    <summary class="cursor-pointer font-semibold">Payload</summary>
    <pre class="mt-2 overflow-auto rounded bg-slate-950 p-3 text-xs">{JSON.stringify(data.request, null, 2)}</pre>
  </details>
</MainLayout>
